스택은 기본적인 자료구조중 하나입니다.
선입후출(먼저 들어온 것이 나중에 나간다)의 특징을 갖고있으며,
많은 언어에서 기본적으로 제공하는 자료구조중 하나이기도 합니다.

C의 경우 직접 만들어야 하고,
C++은 vector가 완벽하게 스택의 역할을 할 수 있습니다.
단, push_back을 할 때 vector가 가득 차있으면 용량을 두배씩 늘려 난이도가 높은 문제에선 메모리초과를 야기할 수 있으니, 주의해야합니다.
Python은 list가 완벽하게 스택의 구조를 띠고있으며,
Kotlin은 mutableListOf<E>가 스택의 역할을 할 수 있습니다.
Java는 java.util.stack을 import해서 쓰도록 합시다. 스택에 시간을 쏟기는 아깝습니다..

여기서 구현한 두 스택은 그렇게 효율적인 편은 아닙니다.
매번 arr을 재조정하는거 자체가 효율적인편이 아니라..
보통 vector처럼 두 배씩 늘리면서 resize단계를 한번씩 거칠겁니다. 아마도요.

유리한 연산에는 push, pop, indexing이 있습니다.
유리한 연산은 모두 O(1)의 시간복잡도를 가집니다.
push : 스택의 맨 뒤에 원소를 하나 추가합니다.
pop : 스택의 맨 뒤 원소를 하나 없앱니다. 언어에 따라 이 값을 함께 반환하기도 합니다.
indexing : N번째 원소를 반환합니다. N번째 원소는 사라지지 않습니다.

불리한 연산에는 가장 뒤가 아닌 곳에 push, pop하는 연산이 있습니다.
이 경우 시간복잡도는 O(n)의 시간복잡도를 가집니다.

iterator로 사용할경우 당연히 시간복잡도는 O(n)을 갖게 됩니다.
