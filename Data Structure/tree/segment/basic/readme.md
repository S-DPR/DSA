세그먼트 트리의 기초입니다.
처음 시작할 때는 구현이 조금 귀찮더라도 Up-Down(재귀)형식을 시도해보시는걸 추천드립니다.
후에는 일반적인 세그트리 문제를 풀 때엔 Bottom-Up형식을 주로 사용하게 됩니다. 빠르고 편하거든요.

세그먼트 트리(이하 세그트리)는 '구간쿼리'를 정말 빠르게 처리하게 도와주는 분할정복+트리DP 자료구조입니다.
기본적으로, '구간의 최솟값', '구간의 최댓값', '구간의 합'을 빠르게 처리할 수 있습니다.
'구간의 합은 DP로 O(1)아닌가?'라고 생각하신다면,
원소의 개수는 100000개고, 업데이트가 50000번 일어나고 쿼리는 업데이트마다 1번 주는 경우를 생각하시면 될것같습니다.

대회용 알고리즘의 시발점이니 흥미가 없거나 코테용을 찾으러 오신분은 DP와 그래프를 풀러 가시면 될것같습니다.
시간복잡도는 초기화에 O(N), 구간쿼리 하나당 O(lgN), 업데이트 하나당 O(lgN)으로, 전체적으로 O(N+lgN)의 형식을 띠며,
보통 쿼리문제는 구간쿼리와 업데이트를 합쳐 M개의 연산을 준다고 하므로
일반적으로는 O((N+M)lgN)의 시간복잡도를 갖게됩니다.

공간복잡도는 O(N^2)만큼을 가집니다. 보통 세그먼트트리를 위한 배열의 크기를 정할 때, (배열의 크기)의 4배를 할당해줍니다.
정확히 말하면 4배가 아니라 1<<ceil(log2((트리의 높이))+1)로 기억하지만, 번거로우니 보통은 4배를 할당합니다.


그럼 어떻게 생긴 모양이냐?를 상상해봅시다. 글로는 한계가 큽니다.
시각적으로 보고싶으시면 블로그를 찾아봅시다.

리프노드의 개수가 N(수열의 길이)개인 완전이진트리를 생각하시고,
그 리프노드에 수열의 원소를 차례대로 집어넣습니다.
그 뒤, 리프노드중에 공통의 부모노드를 갖는 노드들이 있을겁니다.
공통의 부모노드에는 자식노드들의 합을 써넣어줍니다.
이것을 루트노드까지 반복해줍니다.

위 과정이 init입니다. 초기화과정이죠. 자세한건 코드를 보시기 바랍니다.
init을 적용할 때에는 init(1, 0, n-1)로 쓰면 됩니다.


다음은 query함수입니다. query함수는 node, start, end, left, right를 인수로 받으며,
node에는 1, start에는 1, end에는 n을 넣으면 됩니다.
node는 그들을 모두 포함하는 가장 높은 조상노드라는 뜻입니다.
start와 end에는 arr의 시작과 끝을 적어주는겁니다. 분할정복식으로 할 것이기 때문이죠.
left, right는 쿼리문제에서 주는 수를 넣으면 되는데, 'arr의 left~right의 구간쿼리를 구해라!'라는 뜻입니다.

예를 간단하게 들어봅시다. arr이 [1,2,3,4,5]라고 할 때, 1~3의 구간합을 구하고싶습니다.
그러면 query에는 query(1, 1, 5, 1, 3) 이렇게 써넣으면 됩니다.
작동방식에 대해서는 시각적으로 보는게 편한데, 글로 설명해보자면

'start'와 'end'는 '유효범위'입니다.
node가 '제일 높은 조상노드'라고 했는데, 누구의 조상노드냐면 start와 end의 제일 높은 조상노드입니다.
만약 left와 right가 이 유효범위 내에 있다면, 이 node값을 더해주면 되겠죠.

left가 start보다 크다면, start를 start와 end의 중간값으로 설정하여 query를 실행한 뒤, 결과를 이에 더해줍니다.
right도 비슷하게 해줍니다. 업데이트도 비슷한데, 세그먼트트리 기초는 그래도 한국어 자료도 많으니 검색해봅시다.