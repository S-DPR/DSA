import sys
input = sys.stdin.readline
INF = 10**9
# 플루이드 워셜 알고리즘
# 모든 경로의 최단경로를 구하는데 사용하는 알고리즘입니다.
# 시간복잡도는 O(n^3)입니다. 3중 for문을 포함합니다.
# 시간복잡도가 커서 그런가, 노드의 개수가 500개 이하일 때 사용한다고 합니다.

# 노드의 개수와 간선의 개수를 입력받읍시다.
# 노드의 개수는 어차피 1-BASED일테니 1을 더해 받아줍시다.
# 초기 그래프는 노드의 개수^2의 크기이고, 모두 INF로 채워져있습니다.
n, m = int(input())+1, int(input())
G = [[INF]*n for _ in ' '*n]

# 자기 자신으로 가는 경우는 0으로 초기화해줍시다.
for i in range(1, n): G[i][i] = 0

# 간선을 입력받습니다.
# 그래프의 해당 간선은 그 값으로 초기화해줍니다.
# 11404번 문제는 유향그래프이므로 양쪽으로 받아주지 않겠습니다.
for _ in ' '*m:
    a, b, c = map(int, input().split())
    G[a][b] = min(G[a][b], c)

# 플루이드 워셜 알고리즘을 적용해줍니다.
for i in range(1, n):
    for j in range(1, n):
        for k in range(1, n):
            # j->k로 가는 최단경로는,
            # j->k로 가는 비용과
            # j->i->k로 가는 비용을 비교해보고,
            # 더 작은 값을 담아봅니다.

            # i가 1이고 j가 2이고 k가 3이라면
            # 2-3으로 가는 최소비용은 2->3과 2->1->3을 비교해볼 수 있겠죠.
            # 2->4->3같은 경우도 위에서 갱신이 되었다면 i가 4일 때 될겁니다.
            G[j][k] = min(G[j][k], G[j][i] + G[i][k])

for i in G[1:]:
    for j in i[1:]:
        print(j if j != INF else 0, end = ' ')
    print()
