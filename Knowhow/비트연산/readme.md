비트연산자
=========================
가끔 다른사람의 코드를 보다보면 % ^ ~등 이상한 문자가 보이거나,\
문제 자체에서 AND, XOR 연산 결과를 물어보거나,\
풀고보니 비트마스킹이라는 태그가 달려있을 때가 있습니다.\
이 이상한 문자들은 뭘까요?

위 세 상황을 이해하기 위해, <비트연산> 이라는 것을 알아야합니다.\
기본 언어 기초 책에 나오긴 하는데, 일반 연산자 깨우치기도 급급한데 그런거 볼 시간은 없었죠.\
<비트연산자>들의 뜻과 그 활용을 알아봅시다.

------------------
<h2>& : AND 연산자</h2>
&는 and 연산자입니다.\
A&B라고 할 때, A와 B를 이진수로 나타낸 뒤, 모든 자릿수에 대해 다음과 같은 과정을 거쳐 새로운 수를 만듭니다.\
1. A와 B 모두 해당 자릿수가 1일경우 1을 출력합니다.
2. 하나라도 0일경우 0을 출력합니다.
   
결론적으로 아래와 같은 진리표를 갖게 됩니다.
x | y | result
:--:|:--:|:--:
0 | 0 | 0
0 | 1 | 0
1 | 0 | 0
1 | 1 | 1

예를 들어, 3&5를 계산한다면
1. 3은 이진수로 ```11(2)```, 5는 이진수로 ```101(2)```입니다.
2. 3이 자릿수가 적으니 앞에 0을 넣어 자릿수를 맞춰줍니다. 이제 ```011(2)```, ```101(2)```입니다.
3. AND 연산을 수행합니다.
3-1. 맨 앞자리는 3이 0을 갖고있으니 0이 내려옵니다.
3-1. 두번째 자리는 5가 0을 갖고있으니 0이 내려옵니다.
3-2. 세번째 자리는 3과 5 모두 1을 갖고있으니 1이 내려옵니다.
4. 결론적으로 ```001(2)```이므로, ```3&5 = 1```이라는 결과물이 나오게 됩니다.

&연산자는 아래와 같은 성질을 가집니다.
1. **교환법칙** 이 성립합니다.
2. 이진수의 특징에 의해 ```A&1```이 ```True```라면 **A는 홀수**, ```False```라면 **A는 짝수**가 됩니다.
3. **부호비트**에도 AND연산을 수행합니다.
   2-1. ```A < 0 && B < 0```인경우 결과값은 음수입니다.
   2-2. ```A > 0 || B > 0```인경우 결과값은 양수입니다. 
4. 집합론적으로 ```A&B```는 A와 B의 **교집합**을 뜻합니다.
5. 위 의미에 덧붙여, ```A&B == B``` 라면, **B는 A에 포함된다** 라는 의미를 가집니다.

------------------
<h2>\| : OR 연산자</h2>

|는 or연산자입니다.\
A|B일 때, AND와 같은 방법으로 계산하지만 둘 중 한곳에라도 1이 있다면 1을 반환합니다.

x | y | result
:--:|:--:|:--:
0 | 0 | 0
0 | 1 | 1
1 | 0 | 1
1 | 1 | 1

예를 들어, 3|5를 계산한다면
1. 3은 이진수로 ```11(2)```, 5는 이진수로 ```101(2)```입니다.
2. 3이 자릿수가 적으니 앞에 0을 넣어 자릿수를 맞춰줍니다. 이제 ```011(2)```, ```101(2)```입니다.
3. OR 연산을 수행합니다.
3-1. 맨 앞자리는 5가 1을 갖고있으니 1이 내려옵니다.
3-1. 두번째 자리는 3이 1을 갖고있으니 1이 내려옵니다.
3-2. 세번째 자리는 3과 5 모두 1을 갖고있으니 1이 내려옵니다.
4. 결론적으로 ```111(2)```이므로, ```3|5 = 7```이라는 결과물이 나오게 됩니다.

|연산자는 아래와 같은 성질을 가집니다.
1. **교환법칙**이 성립합니다.
2. **부호비트**에도 OR연산을 수행합니다.
   2-1. ```A < 0 || B < 0```인경우 결과값은 음수입니다.
   2-2. ```A > 0 && B > 0```인경우 결과값은 양수입니다.
3. 집합론적으로 ```A|B```는 A와 B의 **합집합**을 뜻합니다.
4. 위 의미에 덧붙여, ```A|B == A```라면, **B는 A에 포함된다**라는 의미를 가집니다.

------------
<h2>^ : XOR 연산자</h2>

^는 XOR 연산자입니다.\
A^B일 때, AND와 같은 방법으로 계산하지만 대신 둘 다 1인경우는 0으로 내보냅니다.

x | y | result
:--:|:--:|:--:
0 | 0 | 0
0 | 1 | 1
1 | 0 | 1
1 | 1 | 0

예를 들어, 3^5를 계산한다면
1. 3은 이진수로 ```11(2)```, 5는 이진수로 ```101(2)```입니다.
2. 3이 자릿수가 적으니 앞에 0을 넣어 자릿수를 맞춰줍니다. 이제 ```011(2)```, ```101(2)```입니다.
3. XOR 연산을 수행합니다.
3-1. 맨 앞자리는 5가 1을 갖고있으니 1이 내려옵니다.
3-1. 두번째 자리는 3이 1을 갖고있으니 1이 내려옵니다.
3-2. 세번째 자리는 3과 5 모두 1을 갖고있으니 0이 내려옵니다.
4. 결론적으로 ```110(2)```이므로, ```3^5 = 6```이라는 결과물이 나오게 됩니다.

^연산자는 아래와 같은 성질을 가집니다.
1. **교환법칙**이 성립합니다.
2. **부호비트**에도 AND연산을 수행합니다.
   2-1. ```AB < 0 ```인경우 결과값은 음수입니다.
   2-2. ```AB > 0```인경우 결과값은 양수입니다.
3. ```A^A == 0```이 항상 성립합니다.
4. 집합론적으로, ```A^B```는 **A와 B의 교집합의 여집합**을 뜻합니다.

-------------
<h2>~ : NOT 연산자</h2>

~는 NOT 연산자입니다.\
위 세 연산자와 다르게, 뒤에 나오는 숫자만 바꿔주는 역할을 수행합니다.\
~A라고 하면 **A를 이진수로 나타냈을 때 1은 0으로, 0은 1로** 바꾸어줍니다.\

x | result
:--:|:--:
0 | 1
0 | 0

예를 들어, ~2를 계산한다면
1. 2는 이진수로 ```0 10(2)```입니다.
2. NOT 연산을 수행합니다.
2-1. 첫번째 자리는 1이니 0이 내려옵니다.
2-2. 두번째 자리는 0이니 1이 내려옵니다.
**2-3. 맨 앞에 부호비트에 대해서도, 0이니 1로 바꾸어줍니다.**
3. 결론적으로 1 01(2)이므로, ```~2 = -1```이라는 결과물이 나오게 됩니다.

부호까지 다르게 만들어주는게 특징입니다.

~연산자는 다음과 같은 성질을 가집니다.
1. ```~A == -A-1```을 항상 만족합니다.
2. ```~~A == A```를 항상 만족합니다.

-----------
<h2><<, >> : 비트 시프트 (bit shift) 연산자</h2>

A << B는 숫자 A의 비트를 왼쪽으로 B개만큼 밀어낸 뒤, 빈 자리에 0을 넣는 수식입니다.\
반대로 A >> B는 숫자 A의 비트를 오른쪽으로 B개만큼 밀어내는 연산입니다. 가장 우측 비트는 사라집니다.

이 부호는 좀 자주 보이는 편인데, 다음과 같은 성질이 있습니다.
1. ```A << B```는 ```A×2^B```와 같은 의미를 가집니다.
2. ```A >> B```는 ```A×2^(-B)```와 같은 의미를 가집니다.

1번성질에 의해, **A가 1이라면 2의 B제곱**을 뜻하는 간단한 수식이 됩니다.\
2의 제곱수는 매우 요긴하게 쓰이므로 그 의미가 깊습니다.

-----------
<h2>비트마스킹 (Bit Mask)</h2>

위에서 조합론적 이야기를 종종 꺼냈었죠.\
바로 이 비트연산을 이용해 **집합을 편하게 표현**할 수 있기 때문입니다.\
예를들어 5개의 노드가 있다고 해봅시다.\
이중 1, 4번 노드에 방문했다면 우리는 비트로 ```01001```로 나타낼 수 있고, 여기서 ```1```은 '방문했음'을 나타냅니다.\
이런식으로 어떤 원소가 존재하는지 존재하지 않는지 빠르고 간편하게 알 수 있는 비트미스킹 구현에 대해 알아봅시다.

1. 비트마스킹의 생성은 그냥 0인 변수를 하나 선언하는 것 입니다.\
   - 별개로, 크기가 B이고 모두 1인 집합이 필요하다면
    ```A = (1 << B)-1```로 선언하면 됩니다.
2. 원소 추가를 하기 위해선 다음과 같이 하면 됩니다.\
   - ```A |= (1 << B)``` : B 추가
3. 원소 삭제를 하기 위해선 다음과 같이 하면 됩니다.\
   - ```A &= ~(1 << B)``` : B 삭제
4. 원소가 있으면 제거하고, 없으면 추가하려면\
   - ```A ^= (1 << B)``` : B 토글
5. 원소 존재여부를 판단하기 위해선 다음과 같이 하면 됩니다.\
   - ```A & (1 << B) == 1``` : ```True```면 B 존재
6. 가장 작은 원소를 찾고싶다면\
   - ```-A&A``` : 1인 가장 작은 원소 출력
7. 가장 작은 원소를 지우고싶다면\
   - ```A &= (A - 1)``` : 가장 작은 원소 제거

쓸모없어보이는 6번은 ```Fenwick Tree```의 주 아이디어로 사용됩니다.\
어쨌든, 위와 같은 방법으로 집합을 표기할 수 있습니다.
 - 장점
    - 메모리 효율이 최상입니다. 4바이트 int로 ```1 << 32```개의 경우의 수를 표현할 수 있습니다.
    - 속도도 최상입니다. 그저 비트비교만 하고 비트만 제거할 뿐이므로 매우 빠릅니다.
 - 단점
   - 많아봐야 63개의 원소를 최대로 가질 수 있습니다. 이 경우 4바이트가 아닌 8바이트 long long형을 사용해야하며, 이 이상 사용시 **오버플로우**가 일어나 찾기 힘든 오류가 될 수도 있습니다.
   - 비트연산 자체의 특성으로, 코드 가독성이 박살이 날 수 있습니다. 필요한 경우에만 사용합시다.