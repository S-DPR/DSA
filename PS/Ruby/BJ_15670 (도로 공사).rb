spl = ->() { gets.split.map &:to_i }
=begin
15670번 도로 공사

길이가 N인 수열이 주어진다. 이후 Q개의 줄에 아래 쿼리가 주어진다.
l r : l부터 r까지 뒤집었을 때, 오름차순이 되는 구간의 개수를 구해보자.
각 쿼리는 독립적이다. 쿼리에 답을 해보자.

하나도 기념비적이지 않은 새해 첫 문제
새해에는 골드5만 풀겠다고 다짐했는데..

예전에 쓰담쓰담 문제 풀다가 생각난 문젠데,
12월 후반은 플레로 꽉 채웠고.. 새해 되고 생각난김에 처리한 문제입니다.
오름차순의 시작부분이면 1을 더해주는 식으로 누적합을 구해줍니다.
뒤집어서도 똑같이 해줍니다.
이제 5개의 수열 A B C D E 기준으로, 그리고 쿼리가 2 4가 나온 기준으로 아래 값을 다 더합니다.

2 4 -> A D C B E
처음부터 A까지 원래 오르막길 개수
E부터 끝까지 원래 오르막길 개수
B부터 D까지 뒤집었을 때 오르막길 개수
A와 D가 오름차순이면 -1
B와 E가 오름차순이면 -1

실수 하나 해서 WA 한번 나온거 너무 슬프네..
=end
N, Q = spl.()
A = [1<<30] + spl.() + [1<<30]
pf, pfr = [0], [0]
(1..N).each do |i|
  pf[i] = A[i-1] > A[i] ? 1 : 0
  pfr[i] = A[i] > A[i+1] ? 0 : 1
end
pfr << 0
(1..N).each do |i|
  pf[i] += pf[i-1]
end
(1..N).reverse_each do |i|
  pfr[i] += pfr[i+1]
end
pf << pf[-1]
R = Q.times.map do
  l, r = spl.()
  ret = 0
  ret += pf[l-1]
  ret += pf[N]-pf[r+1]+1 if r != N
  ret += pfr[l]-pfr[r]+1
  ret -= 1 if l != 1 && A[r] > A[l-1]
  ret -= 1 if r != N && A[r+1] > A[l]
  ret
end
print R.join("\n")
