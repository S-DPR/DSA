=begin
12911번 좋아하는 배열

다음 성질을 만족하는 배열의 개수를 출력해보자.
1. 배열의 길이는 N이다.
2. 배열의 모든 원소는 1 이상 K 이하의 수이다.
3. 모든 arr[i], arr[i+1]에 대해 arr[i] <= arr[i+1] 혹은 arr[i] % arr[i+1] != 0를 만족한다.
단, 1_000_000_007로 나눈 나머지를 출력하자.

몬가몬가 익숙한 이 향기
이유는 몰라도 플레4인 14396과 비슷하게 풀면 됩니다.
골드2치고 쉬웠다는 생각이 드네요. 골드 3~4까지 추락해도 되지 않을까..싶지만
골드4에 이런거 있으면 마음이 꺾일지도 모르니 골드3이나 그냥 골2하위 난이도라 생각하면 될것같네요.

2차원 dp를 만들어줍시다. dp[i][j]는 i번째 자리수에 수 j가 온다면 나오는 경우의 수입니다.
먼저 dp[i-1]의 합을 구합니다. 이 값을 그대로 dp[i][j]에 넣습니다.
j+j부터 K까지, j만큼 건너뛰면서 나오는 각각의 수를 k라고 한다면, dp[i-1][k]의 값을 dp[i][j]에서 빼줍니다.
이 행위를 모든 칸에 대해 반복하고 dp[-1].sum%MOD를 출력합니다.
=end
M = 1_000_000_007
N, K = gets.split.map &:to_i
dp = N.times.map do [0]*(K+1) end
(1..K).each do |k| dp[0][k] = 1 end
(1...N).each do |i|
  prefix = dp[i-1].sum % M
  (1..K).each do |k|
    dp[i][k] = prefix
    (k+k..K).step(k).each do |kk|
      dp[i][k] -= dp[i-1][kk]
    end
    dp[i][k] %= M
  end
end
print dp[-1].sum%M

