import sys
input = sys.stdin.readline
"""
17069번 파이프 옮기기 2

0과 1로 이루어진 이차원 맵이 주어집니다.
기본적으로 (0, 0), (0, 1)에는 파이프가 있으며, 파이프를 다음과 같은 방법으로 이을 수 있습니다.

1
(x, y)에 가로, 대각선 파이프가 있다면 가로로 이어붙일 수 있습니다.
단, (x+1, y)가 1이 아니어야합니다.

2
(x, y)에 세로, 대각선 파이프가 있다면 세로로 이어붙일 수 있습니다.
단, (x, y+1)가 1이 아니어야합니다.

3
(x, y)에 어떤 파이프든 있다면 대각선으로 이어붙일 수 있습니다.
단, (x+1, y), (x+1, y+1), (x, y+1)가 모두 1이 아니어야합니다.

맵의 가장 오른쪽 아래까지 파이프를 잇는 경우의수를 모두 세주세요.

파이프 옮기기 1은 C++로 BFS때려서 풀었는데,
이건 맵 크기는 커지고 시간은 0.5s로 줄어 DP가 강제된다고 하여 북마크했었습니다.
이게 왜 DP인교 하면서 3주정도 북마크에 박아놨는데,
어제 A[i]..어쩌구 문제 풀고 DP에 자신감이 붙어 풀어봤습니다.
가로, 세로, 대각선 방향이 몇개가 있나 저장하는 dp를 만들어
거기에 각 좌표에 각 방향이 몇개가있는가를 보며 세면 O(N^2)에 완료할 수 있습니다.
"""
n = int(input())
M = [list(map(int, input().split())) for _ in ' '*n]
P = [[[0]*n for _ in ' '*n] for __ in ' '*3]
# P[0] : 가로, P[1] : 세로, P[2] : 대각
P[0][0][1] = 1
for i in range(n):
    for j in range(1, n):
        if not M[i][j]:
            P[0][i][j] += P[0][i][j-1] + P[2][i][j-1]
            P[1][i][j] += P[1][i-1][j] + P[2][i-1][j]
        if not (M[i][j] or M[i-1][j] or M[i][j-1]) and i > 0:
            P[2][i][j] += P[0][i-1][j-1] + P[1][i-1][j-1] + P[2][i-1][j-1]
print(sum(P[i][-1][-1] for i in range(3)))
