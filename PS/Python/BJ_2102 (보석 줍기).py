import sys
input = sys.stdin.readline
ini = lambda: int(input())
ins = lambda: [*map(int, input().split())]
inf = float('inf')
"""
2102번 보석 줍기

수열이 주어진다.
길이가 K 이상인 부분 연속 수열 중,
평균의 최댓값에 1000을 곱한 뒤 내림한 값을 출력해보자.

오..
누적합에도 테크닉이 있구나..

수열의 모든 부분 연속 수열에서 최대 합을 얻으려면 어떻게해야하는가? 를 고민해봅시다.
음, 모든이면 간단하죠. 그냥 Kadene 한번 싹 박으면 금방 나오죠.
그러면 이거를 한 번 더 활용해봅시다. 길이가 K 이상인 모든 부분수열에 대해서는?

네, 이거도 그냥 Kadene 한번 박고 누적합 한번 써주면 됩니다.
이게 같은 이름의 골드 2문제(였는데 골드1이된문제)입니다.

아, 그런데 이번엔 평균이라네요.
평?균?
일단 평균을 구한다하면, 일반적으로 배열에서 평균값 빼보는게 국룰입니다.
예를들어 내가 수열에서 몇 개를 뽑아 K 이상으로 만들고싶다?
그냥 수열에 다 K 뺀 뒤 0 이상인거 다 주워오면 됩니다.
만약 연속 부분수열이면 그 합이 0 이상이 되도록 주워오면 되겠죠.

근데 최대평균? 이건 매개변수탐색 한방 박아서 결정문제로 만들면됩니다.
그런데 길이가 K이상? 흠...
전 전에 푼것처럼 카다네랑 같이 써보려했다가 망했고 열심히 서칭한결과..

누적합에서 K가 주어질 때 누적최대합을 구하는 테크닉을 찾았습니다.
생각해보면, 1~i까지 최댓값이고 1~j까지 최솟값이면, 둘을 빼면 항상 최댓값이겠네요?
물론 j < i이기 때문에 항상 mx를 먼저 계산하고 mn을 계산합니다.
그리고, 최솟값이 1 이상이면 안빼는게 당연히 이득이기때문에 min은 0으로 시작합니다.
그러면 이제 내부 pf만 잘 써주면 항상 길이가 K 이상인 연속부분수열의 최대합을 구할 수 있겠네요.

초기 배열에 x를 빼준 뒤 pf를 만들면 그건 평균값에 해당하는 배열이 되므로,
최종 mx값이 0 이상일경우 길이가 K 이상이고 평균도 x 이상인 부분연속수열이 존재함을 알 수 있습니다.
와.. 진짜 신기하다.. 원래 길게 안쓰는데 되게 길게썼네..
"""
def chk(x):
    pf = [0]
    for i in [*map(lambda k: k-x, A)]:
        pf.append(pf[-1]+i)
    mx, mn = -inf, 0
    for i in range(M, N+1):
        mx = max(mx, pf[i]-mn)
        mn = min(mn, pf[i-M+1])
    return mx >= 0

N, M = ins()
A = [ini() for _ in ' '*N]
lo, hi = 0, N*2001
while hi-lo >= 1e-4:
    mid = (lo + hi) / 2
    if not chk(mid):
        hi = mid
    else:
        lo = mid
print(int(hi*1000))
