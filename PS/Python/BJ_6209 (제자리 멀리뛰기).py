import sys
input = sys.stdin.readline
"""
6209번 제자리 멀리 뛰기

목표지점의 수직선상 좌표 d와 징검다리 개수 n,
징검다리를 없앨 수 있는 횟수 m이 주어지고,
이후 징검다리의 수직선상 좌표가 n개 주어집니다.

징검다리를 m개 빼면 각 징검다리의 거리가 나올거고,
각기 다른 방식으로 다리를 빼봐서 나온 거리중 최솟값들을 모은다고 합시다. 
그 최솟값 배열중 최댓값을 구하는 문제입니다.

마지막으로, 주어지는 n개의 수직선상 좌표는 모두 d 이하입니다.

첨엔 그리디인거 빼곤 잘 모르겠어서 세그트리랑 펜윅트리로
현재 제일 작은 수랑 다음 인덱스 구해서 하려다가
틀렸습니다 10번정도 맞았습니다..

이후 정신 좀 차리고 이게 매개변수탐색 연습하려고 뽑아온 랜덤 문제라..
그 점을 이용해서 매개변수탐색을 사용했습니다.
매개변수탐색 이거 꽤 어렵네요. 디버깅도 쉽지않고.
"""

"""
매개변수 탐색에 이용되는 find_loweer 함수입니다.
사실 함수 이름 잘못지은거긴 한데..
일단 이게 무슨 역할을 하냐면,
변수로 배열과 기준값을 가져옵니다.

이후 for문으로 각 징검다리의 거리를 재는데,
만약 거리가 k개 미만이라면 그 돌을 지워버릴겁니다.
k 이상이라면 그 돌을 탈겁니다. standard에 그 변수를 저장할거구요.
for문을 다 돈 뒤에는 최종 목적지와 현재 standard의 거리를 비교합니다.
그게 k보다 작으면 그 돌도 지워야하죠.
이후, rmcnt (지운 횟수)를 return합니다.

이게 가능한 이유는 그리디이기 때문입니다.
거리가 k 미만인게 있으면 결국 거리 최솟값 배열의 최댓값은 그 값이 되어야하는데,
그 돌이 있으면 이 가정에 어긋나버리죠. 그래서 그 돌은 '반드시'지워야합니다.
"""
def find_lower(arr, k):
    standard = rmcnt = 0
    for i in arr:
        if i - standard >= k:
            standard = i
        else:
            rmcnt += 1
    if d - standard < k: rmcnt += 1
    return rmcnt

d, n, m = map(int, input().split())
arr = sorted(int(input()) for _ in ' '*n)
if m == n: print(d) # 예외처리입니다. m이랑 n이랑 같으면 아래 매개변수탐색이 아얘 작동을 못하더라구요.
else:
    l = 1; r = arr[-1]
    # 매개변수는 거리의 최솟값 1과 배열의 최댓값 arr[-1]입니다.
    while l < r:
        k = l + r >> 1
        if find_lower(arr, k) > m:
            r = k
        else:
            l = k + 1
    print(r-1)
