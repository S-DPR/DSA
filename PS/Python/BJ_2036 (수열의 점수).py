import sys
from collections import deque
input = sys.stdin.readline

"""
2036번 수열의 점수
랜덤한 문제를 풀어볼 때는 저는 자료구조보단 알고리즘을 먼저 생각합니다.
정확히 말하면, '어떻게 하면 풀리겠네~'가 아니라,
'이거 완전탐색인가?' 이런 추상적인 느낌으로 생각하는겁니다.
보통 입력의 최대 값, 입력 모양, 문제 상태를 보고 결정합니다.
그러니, 문제를 읽고 알고리즘을 생각해봅시다.

문제요약
수열 S가 주어진다. (S의 길이 <= 100000, |각 원소| <= 1000000)
이 S에서 어떤 두 수를 골라 곱한 값을 새로운 수열 K에 넣는다 하자.
또한, S에서 수 하나를 골라 새로운 수열 K에 넣을 수 있다.
S를 모두 비운 뒤, 이 K에 있는 원소를 모두 합한 값을 T라고 하자.
수열 S가 주어질 때, T의 최댓값을 구하시오.
"""

"""
제 알고리즘 탐색 알고리즘은, 
 : 뭔가 입력값이 주는 시간에 비해 수상하게 작다 - 완전탐색
 : 이상한 지도를 준다, 뭔가 연결할 수 있을거같다 - 그래프
 : 어떤 것(배열따위)을 처음에 주고 거기에 이상한 연산결과(구간의 최댓값 등등)를 계속 물어본다 - 쿼리
 : 봤을때 이거 그냥 그때그때 최선을 다하면 될거같다 - 그리디
 : 그리디로 했는데 틀렸고 완전탐색은 아무리 봐도 아닌거같다 - DP
 : 계속 생각해봤는데 못 풀거같다 - 수학, 기하학, 알고리즘 짬뽕, 자료구조의 요상한 활용 등등
입니다.

저 알고리즘에 따르면, 그리디였습니다.
2 2 4 6이 있을 때, 2 6 / 2 4 이렇게 쪼개는거보단 그냥 최댓값끼리 곱해서 4 6 / 2 2 이렇게 곱하는게 크잖아요?
그냥 거기서 "이거 반례 있나?"라고 생각하면서 코드 짰습니다.
"""
score = 0
# 입력을 모두 받고, 정렬한 뒤 deque로 만들어줍시다.
arr = deque(sorted(list(int(input()) for _ in ' '*int(input()))))

# arr의 길이가 2 이상이고, 두 번째로 큰게 1보다 크다면, 맨 뒤에 두개를 터뜨려 score에 곱해줍시다.
# 1의 경우, 결국 곱하면 자기 자신이 나오니 그냥 1을 더하는게 더 낫습니다. 그러니 1은 예외처리 해주어야합니다.
while len(arr) >= 2 and arr[-2] > 1: score += arr.pop() * arr.pop()

# arr의 길이가 2 이상이고, 제일 작은거나 그다음으로 작은게 0 이하라면, 둘을 곱해줍시다.
# 이 부분에서 예외처리를 못해 WA(Wrong Answer)가 많이 납니다. 0도 감안을 해주어야합니다.
while len(arr) >= 2 and arr[1] <= 0 and arr[0] <= 0: score += arr.popleft() * arr.popleft()

# 결국, 1이나 처분되지 못한 음수등이 남습니다. 남은 arr을 전부 score에 넣습니다.
while arr: score += arr.pop()
print(score)
