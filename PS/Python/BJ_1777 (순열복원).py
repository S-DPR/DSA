import sys
input = sys.stdin.readline
"""
1777번 순열복원

이제 열심히 백준 북마크 정리하려고 합니다.
재밌어보이는문제 무지성 북마크하고다녀서 한페이지가 넘어갈거같아요..
난이도 높은건 쳐내고 할만한거만 풀어봅시다.
첫 문제는, 제가 버블소트를 풀고 기고만장해졌을때 들어갔다가 시간초과 맞고 나온 순열복원입니다.

문제는 Inversion Sequence를 줄테니 원래 수열을 찾으라고 합니다.
Inversion Sequence(이하 IS)는, i < j이고 arr[i] > arr[j]인 수의 개수라고 합니다.
주어지는 IS의 입력의 첫번째 값은 1의 IS, 두번째는 2의 IS.. N번째는 N의 IS라고 합니다.
수 순서대로 주어진다는건 중요한 정보니 잊지맙시다.

이걸 좀 쉽게 푸는 방법은 직접 해보는겁니다.
예제 1번을 직접 해봅시다.

Input
0 1 0 2 2 1 2 0

Process
0 0 0 0 0 0 0 8
0 0 0 0 7 0 0 8
0 0 0 0 7 6 0 8
0 0 5 0 7 6 0 8
0 4 5 0 7 6 0 8
0 4 5 0 7 6 3 8
2 4 5 0 7 6 3 8

Result
2 4 5 1 7 6 3 8

생각해보면 N이 어디 인덱스에 있는지는 대놓고 알려주는거랑 다를게 없습니다.
N이 0이면 맨 뒤고, 1이면 거기서 한칸 앞이고, N-1이면 맨 앞이겠죠.
그 정보 하나로 이제 모든 수의 위치를 알 수 있습니다.

이 문제는 이분탐색을 하거나 세그트리를 쓰거나 하는건데요.
저는 당연히 세그트리를 썼습니다. 시간복잡도는 N(lgN)^2이라고 합니다.
(이분탐색은 NlgN이라고 합니다.)

그래서 세그트리를 어떻게 썼냐, 하면.
먼저 현재 수열을 반으로 나눕니다.
그리고 오른쪽에 빈 자리가 몇개 남았나 생각해봅시다.
왜냐면 이 수를 넣고나서 들어오는 모든 수는 다 이 수보다 작아서 IS에 영향을 주거든요.

만약에 그 수를 세었더니 이 수의 IS보다 작다면, 오른쪽을 전체 배열로 보고 이 과정을 반복합니다.
반대로 크거나 같다면 왼쪽을 전체 배열로 보고 위 과정을 반복합니다.
그렇게해서 배열의 크기가 1이 된다면 그 자리에 이 수를 넣으면 되는겁니다.
이해가 안된다면 위 예제를 보면서 이 과정을 생각해봅시다.
"""

# Bottom-Up 세그트리 함수
def update(idx):
  idx += n-1; seg[idx] = 0
  while idx > 1:
    seg[idx>>1] = seg[idx] + seg[idx^1]
    idx >>= 1

def query(l, r):
  res = 0
  l += n-1; r += n-1
  while l <= r:
    if l&1:
      res += seg[l]; l += 1
    if not r&1:
      res += seg[r]; r -= 1
    l >>= 1; r >>= 1
  return res

n = int(input())
arr = list(map(int, input().split()))
ans = [0]*n

# 세그트리 구축
seg = [0]*(n*2)
for i in range(n):
  seg[n+i] = 1
for i in range(n-1, 0, -1):
  seg[i] = seg[i<<1] + seg[i<<1|1]

# 위에서 말한 알고리즘은 이렇게 구현할 수 있습니다.
for k, i in zip(arr[::-1], range(n, 0, -1)):
  s = 1; e = n
  while s != e:
    m = s + e >> 1
    if (right:=query(m+1, e)) > k:
      s = m+1
    else:
      e = m; k -= right
  update(s)
  ans[s-1] = i
print(*ans)
