package Main;

import java.util.Scanner;

class Main {
	/*
	 * 1주차에 코드 올려줬을 때 자바의 자료형에 대해 알 수 있었을 것이다.
	 * 자바에서 함수를 선언할 때에는 그 자료형들 + void를 합쳐 반환값을 지정해주어야한다.
	 * class와 관련된 설명이 있으니 유의바란다.
	 * 
	 * 
	 * 첫 번째에는 public / private / protected 중 하나를 쓴다.
	 * 이는 객체지향언어의 특성이다.
	 * 
	 * public은 "모든 것들에 대하여 접근을 허용한다." 라는 뜻이다.
	 * 어디서 불러오기만 했다면 어디서든지 사용/변경 가능하다는 말이다.
	 * 
	 * private는 "자신에게 상속받았거나 같은 패키지 내에 있는 것에 대하여 접근을 허용한다." 라는 뜻이다.
	 * 말 그대로, 저 두 조건중 하나만 챙겼다면 private여도 접근을 할 수 있다는 말이다.
	 * 
	 * protected는 "자신만 사용하겠다" 라는 뜻이다.
	 * 자기 자신만 자기를 사용할 수 있다. 이는 보통 class에서 쓰며, 일반적인 함수 정의에는 많이 사용하지 않는다.
	 * 
	 * 생략도 가능은 한데, 이 경우 같은 패키지 내에 있는 것들만 접근할 수 있게 하겠다. 라는 뜻이다.
	 * 
	 * 
	 * 두 번째에는 static을 쓰거나 쓰지 않을 수 있다. (이 부분은 읽어도 모를테니 결론만 보자)
	 * 
	 * static을 쓰지 않을경우 '자기를 만들 때 마다 서로 다른 하나' 가 된다.
	 * 예컨데, T라는 클래스에 K라는 Non-Static 변수가 있다고 하자.
	 * 이후 T s1 = new T(); T s2 = new T(); 로 s1과 s2를 T로 생성하고,
	 * s1.K = 3; s2.K = 5; 이러고 s1.K와 s2.K를 각각 출력할경우 각각 3과 5가 출력된다.
	 * 
	 * static을 쓸경우 '그 클래스 모두가 사용하는 변수 하나'가 된다.
	 * 위 예시에서 K가 static이라고 할경우,
	 * s1.K, s2.K 모두 5가 출력된다.
	 * s1.K를 바꿀 때 같은 클래스를 받아온 s2.K도 같이 바뀌는거다.
	 * 
	 * 함수 사용시에는 보통 static을 쓴다.
	 * 
	 * 
	 * 세 번째에는 반환타입을 쓴다.
	 * 반환타입은 반드시 그 함수가 리턴하는 변수의 타입과 같아야하며,
	 * 특별히 반환하지 않는다면 void를 써야한다.
	 * 어떤경우에는 void, 어떤경우에는 int 이런식으로 반환하는건 불가능하다.
	 * 
	 * 
	 * 네 번째에는 메소드의 이름을 쓴다.
	 * 메소드란, C나 Python이나 Go나 Kotlin의 함수와 동치이며,
	 * 첫글자는 반드시 소문자 라는 규칙이 지켜져야한다.
	 * 
	 * 
	 * 다섯번째에는 인자를 쓴다.
	 * 이 함수를 사용할 때 무슨 변수가 필요한지를 말하며, 소괄호로 여닫는다.
	 * [자료형] [변수 이름] 이렇게 쓴다.
	 * 여러개 필요하다면 콤마로 구분하여 쓴다.
	 * void는 자료형에 쓸 수 없으며, 굳이 변수를 입력받을 필요가 없으면 그냥 ()만 쓰면된다.
	 * 
	 * 참고로 main메소드가 반드시 맨 밑에 갈 필요는 없으며, 이는 코드 작성하는사람 마음이다.
	 * 그런데 어.. main이 중간에 껴있으면.. 음.. 보기가 좀 그렇다할까..
	 */
	public static int plus(int i, int j) {
		int sum;
		sum = i + j;
		return sum;
	}

	// 같은 이름 함수라도 들어오는 변수가 다르다면 문제없다.
	public static float plus(float i, float j) {
		return i + j;
	}

	public static int lowerbound(int[] arr, int k) {
		int l = 0, r = arr[arr.length - 1];
		while (l < r) {
			int m = (l + r) >> 1;
			if (arr[m] >= k)
				r = m;
			else
				l = m + 1;
		}
		return r;
	}

	public static void canIChangeThis(int k) {
		k++;
	}

	public static void main(String args[]) {

		Scanner t = new Scanner(System.in);

		// 받은 인자를 함수 내에서 바꿀 수 있는가?
		int a = 10;
		System.out.println(a);
		canIChangeThis(a);
		System.out.println("a");

		// 재귀함수
		System.out.println(factorial(5));

		t.close();
	}

	/*
	 * 다시 재 (再)
	 * 돌아갈 귀 (歸)
	 * 하여 재귀다. 다시 돌아가 자기 자신을 부른다는 뜻이다.
	 * 
	 * 미리 말해두는데 모든 재귀문은 반복문으로, 반복문은 재귀로 짤 수 있으며
	 * 반복문이 재귀보다 훨씬 빠르다.
	 * 
	 * "않이 글어면 제귀 웨써요?????????" 할 수 있겠지만
	 * 보기 쉬운코드와 빠른코드는 또 별개의 이야기라서,
	 * 재귀를 써야 보기 쉬운코드가 있고, 반복을 써야 보기도 짜기도 쉬운코드가 있다.
	 * 
	 * 그리고 코드 드럽게 짜놓고 한 1년뒤에 보면 과거의 자신을 욕하게되는데,
	 * 그때 가서 뭘 추가하려 해봐야 코드 드러워서 여기 고쳤더니 저기가 펑 터지고 이러면 답이없다.
	 * 이런 연유로, 속도를 어느정도 포기하고서라도 유지보수를 위해 재귀를 쓸 가치는 충분하다, 라고 볼 수 있다.
	 * 
	 * 예시는 재귀함수 예시의 대명사 팩토리얼이다.
	 * 문제를 푸는데 있어서 재귀를 쓸 때 가장 중요한건 자신감인데,
	 * 'N이 참이고 N+1이 참이면 이 재귀는 참이다.' 라는 마음가짐을 잃지 않아야한다.
	 * 그니까 니가 짠 재귀 코드를 한번 디버깅 돌려서 원하는 값이 나온다면,
	 * 그 이후로 재귀 건들면 큰일난다는 뜻이다.
	 * 
	 * 재귀는 특히 11중 for문보다 매우매우매우 어려운 초고난이도 디버깅 난이도를 자랑하기때문에,
	 * 자신이 짠 재귀에 대해 자신감을 잃는순간 길을 잃고 방황하게 된다.
	 * 재귀 디버깅은 코드에 직접적으로 큰 수에 제한걸지 않은이상 작은 값 넣고 1~2번 성공하면 끝인거다.
	 * 
	 * 다음으로 중요한건 '재귀를 불렀다면 그 함수는 다 끝낸 뒤 다음일을 한다.' 인데,
	 * 이부분은 main부분에서 함수를 쓸 때를 생각하면 쉽다.
	 * main에서 printf를 썼다고 main이 종료되는가?
	 * 아니다. printf를 호출한 뒤 종료하고 main부분을 계속 이어간다.
	 * 재귀도 마찬가지다. A()함수가 A()함수를 불렀다면, 부른 A()함수를 종료하고 나서 그 다음 코드를 이어간다.
	 */
	public static int factorial(int k) {
		if (k > 10)
			return -1;
		// 팩토리얼은 조금 큰 수르 넣어도 수가 미친듯이 증가해서 그냥 10 초과하는 수가 들어오면 -1 리턴시켰다.
		if (k <= 1)
			return 1;
		// 재귀에는 '중단조건'이 필수이다. 없으면 재귀를 탈출할 수 없다.
		return k * factorial(k - 1); // 재귀는 어디서든지 자기 자신을 한 번 이상 부른다.
	}
	/*
	 * 머릿속으로 재귀에 대해 생각을 해보자.
	 * factorial(5)를 호출할경우 어떻게될까?
	 * 1 : 먼저 if문 다 통과하고 return 5 * factorial(5-1) 까지 갈 것이고,
	 * 2 : 두번째도 if문 다 통과하고 return 4 * factorial(4-1) 까지 갈거다.
	 * 3 : 세번째도 if문 다 통과하고 return 3 * factorial(3-1) 까지,
	 * 4 : 네번째도 if문 다 통과하고 return 2 * factorial(2-1),
	 * 5 : 5번째로는 if (k <= 1)에 걸려 return 1을 하게된다. 이 시점에서 다섯번째 함수는 종료하게 된다.
	 * 6 : 다시 네번째로 돌아가자. return 2 * factorial(2-1)이었는데 factorial(2-1)이 1을 return하였다.
	 * 그러므로, return 2 * 1이 되어 return 2를 하고 return문이 끝났으니 네번째 함수를 종료한다.
	 * 7 : 세번째로 돌아가, return 3 * factorial(3-1)안데, factorial이 2를 반환했으니 3*2가 되고 6을
	 * return하고 종료한다.
	 * 8 : 두번째로, return 4 * 6, 즉 return 24를 하고 종료한다.
	 * 9 : 처음 시점으로 돌아가, return 5 * 24를 반환하고 모든 재귀함수 호출이 종료되게 된다.
	 * 
	 * 팩토리얼이 간단해서 이렇게 글로 쓸 수 있는거지, 실제로는 이렇게 모든 재귀를 생각하여 시뮬레이션 할 수는 없다.
	 * 재귀는 주로 '백트래킹', 'DFS'에서 사용되므로, '아 몰랑 안해~~' 하면 안된다. 적어도 DFS때문에라도 알아야한다.
	 */
}